   1               		.file	"Descriptors.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.CALLBACK_USB_GetDescriptor,"ax",@progbits
  11               	.global	CALLBACK_USB_GetDescriptor
  13               	CALLBACK_USB_GetDescriptor:
  14               	.LFB66:
  15               		.file 1 "Descriptors.c"
   1:Descriptors.c **** /*
   2:Descriptors.c ****              LUFA Library
   3:Descriptors.c ****      Copyright (C) Dean Camera, 2010.
   4:Descriptors.c **** 
   5:Descriptors.c ****   dean [at] fourwalledcubicle [dot] com
   6:Descriptors.c ****       www.fourwalledcubicle.com
   7:Descriptors.c **** */
   8:Descriptors.c **** 
   9:Descriptors.c **** /*
  10:Descriptors.c ****   Copyright 2010  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:Descriptors.c **** 
  12:Descriptors.c ****   Permission to use, copy, modify, distribute, and sell this
  13:Descriptors.c ****   software and its documentation for any purpose is hereby granted
  14:Descriptors.c ****   without fee, provided that the above copyright notice appear in
  15:Descriptors.c ****   all copies and that both that the copyright notice and this
  16:Descriptors.c ****   permission notice and warranty disclaimer appear in supporting
  17:Descriptors.c ****   documentation, and that the name of the author not be used in
  18:Descriptors.c ****   advertising or publicity pertaining to distribution of the
  19:Descriptors.c ****   software without specific, written prior permission.
  20:Descriptors.c **** 
  21:Descriptors.c ****   The author disclaim all warranties with regard to this
  22:Descriptors.c ****   software, including all implied warranties of merchantability
  23:Descriptors.c ****   and fitness.  In no event shall the author be liable for any
  24:Descriptors.c ****   special, indirect or consequential damages or any damages
  25:Descriptors.c ****   whatsoever resulting from loss of use, data or profits, whether
  26:Descriptors.c ****   in an action of contract, negligence or other tortious action,
  27:Descriptors.c ****   arising out of or in connection with the use or performance of
  28:Descriptors.c ****   this software.
  29:Descriptors.c **** */
  30:Descriptors.c **** 
  31:Descriptors.c **** /** \file
  32:Descriptors.c ****  *
  33:Descriptors.c ****  *  USB Device Descriptors, for library use when in USB device mode. Descriptors are special
  34:Descriptors.c ****  *  computer-readable structures which the host requests upon device enumeration, to determine
  35:Descriptors.c ****  *  the device's capabilities and functions.
  36:Descriptors.c ****  */
  37:Descriptors.c **** 
  38:Descriptors.c **** #include "Descriptors.h"
  39:Descriptors.c **** 
  40:Descriptors.c **** /** HID class report descriptor. This is a special descriptor constructed with values from the
  41:Descriptors.c ****  *  USBIF HID class specification to describe the reports and capabilities of the HID device. This
  42:Descriptors.c ****  *  descriptor is parsed by the host and its contents used to determine what data (and in what enco
  43:Descriptors.c ****  *  the device will send, and what it may be sent back from the host. Refer to the HID specificatio
  44:Descriptors.c ****  *  more details on HID report descriptors.
  45:Descriptors.c ****  */
  46:Descriptors.c **** const USB_Descriptor_HIDReport_Datatype_t PROGMEM JoystickReport[] =
  47:Descriptors.c **** {
  48:Descriptors.c **** 	0x05, 0x01,          /* Usage Page (Generic Desktop)                       */
  49:Descriptors.c **** 	0x09, 0x04,          /* Usage (Joystick)                                   */
  50:Descriptors.c **** 
  51:Descriptors.c **** 	0xa1, 0x01,          /* Collection (Application)                           */
  52:Descriptors.c **** 	0x09, 0x01,          /*   Usage (Pointer)                                  */
  53:Descriptors.c **** 
  54:Descriptors.c **** 	/* 8 axes, signed 16 bit resolution, range 0 to 2000 (16 bytes) */
  55:Descriptors.c **** 	0xa1, 0x00,          /*   Collection (Physical)                            */
  56:Descriptors.c **** 	0x05, 0x01,          /*     Usage Page (Generic Desktop)                   */
  57:Descriptors.c **** 	0x09, 0x30,          /*     Usage (X)                                      */
  58:Descriptors.c **** 	0x09, 0x31,          /*     Usage (Y)                                      */
  59:Descriptors.c **** 	0x09, 0x32,          /*     Usage (Analog1)                                */
  60:Descriptors.c **** 	0x09, 0x33,          /*     Usage (Analog2)                                */
  61:Descriptors.c **** //	0x09, 0x34,          /*     Usage (Analog3)                                */
  62:Descriptors.c **** //	0x09, 0x35,          /*     Usage (Analog4)                                */
  63:Descriptors.c **** //	0x09, 0x36,          /*     Usage (Analog5)                                */
  64:Descriptors.c **** //	0x09, 0x37,          /*     Usage (Analog6)                                */
  65:Descriptors.c **** //  0x09, 0x38,          /*     Usage (Analog6)                                */
  66:Descriptors.c **** 	0x15, 0x00,          /*     Logical Minimum (0)                       */
  67:Descriptors.c **** 	0x26, 0xD0, 0x07,    /*     Logical Maximum (2000)                        */
  68:Descriptors.c **** //	0x26, 0xDC, 0x05,    /*     Logical Maximum (1500)                        */
  69:Descriptors.c **** 	0x75, 16,            /*     Report Size (16)                               */
  70:Descriptors.c **** //	0x95, 9,             /*     Report Count (9)                               */
  71:Descriptors.c **** 	0x95, 4,             /*     Report Count (9)                               */
  72:Descriptors.c **** 	0x81, 0x82,          /*     Input (Data, Variable, Absolute, Volatile)     */
  73:Descriptors.c **** 	0xc0,                /*   End Collection                                   */
  74:Descriptors.c **** 
  75:Descriptors.c **** 	/* 40 buttons, value 0=off, 1=on (5 bytes) */
  76:Descriptors.c **** //	0x05, 0x09,          /*   Usage Page (Button)                              */
  77:Descriptors.c **** //	0x19, 1,             /*     Usage Minimum (Button 1)                       */
  78:Descriptors.c **** //	0x29, 40,            /*     Usage Maximum (Button 40)                      */
  79:Descriptors.c **** //	0x15, 0x00,          /*   Logical Minimum (0)                              */
  80:Descriptors.c **** //	0x25, 0x01,          /*   Logical Maximum (1)                              */
  81:Descriptors.c **** //	0x75, 1,             /*   Report Size (1)                                  */
  82:Descriptors.c **** //	0x95, 40,            /*   Report Count (40)                                */
  83:Descriptors.c **** //	0x81, 0x02,          /*   Input (Data, Variable, Absolute)                 */
  84:Descriptors.c **** 	0xc0                 /* End Collection                                     */
  85:Descriptors.c **** };
  86:Descriptors.c **** 
  87:Descriptors.c **** /** Device descriptor structure. This descriptor, located in FLASH memory, describes the overall
  88:Descriptors.c ****  *  device characteristics, including the supported USB version, control endpoint size and the
  89:Descriptors.c ****  *  number of device configurations. The descriptor is read out by the USB host when the enumeratio
  90:Descriptors.c ****  *  process begins.
  91:Descriptors.c ****  */
  92:Descriptors.c **** const USB_Descriptor_Device_t PROGMEM DeviceDescriptor =
  93:Descriptors.c **** {
  94:Descriptors.c **** 	.Header                 = {.Size = sizeof(USB_Descriptor_Device_t), .Type = DTYPE_Device},
  95:Descriptors.c **** 
  96:Descriptors.c **** 	.USBSpecification       = VERSION_BCD(01.10),
  97:Descriptors.c **** 	.Class                  = 0x00,
  98:Descriptors.c **** 	.SubClass               = 0x00,
  99:Descriptors.c **** 	.Protocol               = 0x00,
 100:Descriptors.c **** 
 101:Descriptors.c **** 	.Endpoint0Size          = FIXED_CONTROL_ENDPOINT_SIZE,
 102:Descriptors.c **** 
 103:Descriptors.c **** 	.VendorID               = 0x03EB,
 104:Descriptors.c **** 	.ProductID              = 0x2043,
 105:Descriptors.c **** 	.ReleaseNumber          = 0x0000,
 106:Descriptors.c **** 
 107:Descriptors.c **** 	.ManufacturerStrIndex   = 0x01,
 108:Descriptors.c **** 	.ProductStrIndex        = 0x02,
 109:Descriptors.c **** 	.SerialNumStrIndex      = NO_DESCRIPTOR,
 110:Descriptors.c **** 
 111:Descriptors.c **** 	.NumberOfConfigurations = FIXED_NUM_CONFIGURATIONS
 112:Descriptors.c **** };
 113:Descriptors.c **** 
 114:Descriptors.c **** /** Configuration descriptor structure. This descriptor, located in FLASH memory, describes the usa
 115:Descriptors.c ****  *  of the device in one of its supported configurations, including information about any device in
 116:Descriptors.c ****  *  and endpoints. The descriptor is read out by the USB host during the enumeration process when s
 117:Descriptors.c ****  *  a configuration so that the host may correctly communicate with the USB device.
 118:Descriptors.c ****  */
 119:Descriptors.c **** const USB_Descriptor_Configuration_t PROGMEM ConfigurationDescriptor =
 120:Descriptors.c **** {
 121:Descriptors.c **** 	.Config =
 122:Descriptors.c **** 		{
 123:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Configuration_Header_t), .Type = DTYPE_
 124:Descriptors.c **** 
 125:Descriptors.c **** 			.TotalConfigurationSize = sizeof(USB_Descriptor_Configuration_t),
 126:Descriptors.c **** 			.TotalInterfaces        = 1,
 127:Descriptors.c **** 
 128:Descriptors.c **** 			.ConfigurationNumber    = 1,
 129:Descriptors.c **** 			.ConfigurationStrIndex  = NO_DESCRIPTOR,
 130:Descriptors.c **** 
 131:Descriptors.c **** 			.ConfigAttributes       = (USB_CONFIG_ATTR_BUSPOWERED | USB_CONFIG_ATTR_SELFPOWERED),
 132:Descriptors.c **** 
 133:Descriptors.c **** 			.MaxPowerConsumption    = USB_CONFIG_POWER_MA(100)
 134:Descriptors.c **** 		},
 135:Descriptors.c **** 
 136:Descriptors.c **** 	.HID_Interface =
 137:Descriptors.c **** 		{
 138:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Interface_t), .Type = DTYPE_Interface},
 139:Descriptors.c **** 
 140:Descriptors.c **** 			.InterfaceNumber        = 0x00,
 141:Descriptors.c **** 			.AlternateSetting       = 0x00,
 142:Descriptors.c **** 
 143:Descriptors.c **** 			.TotalEndpoints         = 1,
 144:Descriptors.c **** 
 145:Descriptors.c **** 			.Class                  = 0x03,
 146:Descriptors.c **** 			.SubClass               = 0x00,
 147:Descriptors.c **** 			.Protocol               = HID_NON_BOOT_PROTOCOL,
 148:Descriptors.c **** 
 149:Descriptors.c **** 			.InterfaceStrIndex      = NO_DESCRIPTOR
 150:Descriptors.c **** 		},
 151:Descriptors.c **** 
 152:Descriptors.c **** 	.HID_JoystickHID =
 153:Descriptors.c **** 		{
 154:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_HID_Descriptor_t), .Type = DTYPE_HID},
 155:Descriptors.c **** 
 156:Descriptors.c **** 			.HIDSpec                = VERSION_BCD(01.11),
 157:Descriptors.c **** 			.CountryCode            = 0x00,
 158:Descriptors.c **** 			.TotalReportDescriptors = 1,
 159:Descriptors.c **** 			.HIDReportType          = DTYPE_Report,
 160:Descriptors.c **** 			.HIDReportLength        = sizeof(JoystickReport)
 161:Descriptors.c **** 		},
 162:Descriptors.c **** 
 163:Descriptors.c **** 	.HID_ReportINEndpoint =
 164:Descriptors.c **** 		{
 165:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 166:Descriptors.c **** 
 167:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DESCRIPTOR_DIR_IN | JOYSTICK_EPNUM),
 168:Descriptors.c **** 			.Attributes             = (EP_TYPE_INTERRUPT | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 169:Descriptors.c **** 			.EndpointSize           = JOYSTICK_EPSIZE,
 170:Descriptors.c **** 			.PollingIntervalMS      = 0x0A
 171:Descriptors.c **** 		}
 172:Descriptors.c **** };
 173:Descriptors.c **** 
 174:Descriptors.c **** /** Language descriptor structure. This descriptor, located in FLASH memory, is returned when the h
 175:Descriptors.c ****  *  the string descriptor with index 0 (the first index). It is actually an array of 16-bit integer
 176:Descriptors.c ****  *  via the language ID table available at USB.org what languages the device supports for its strin
 177:Descriptors.c ****  */
 178:Descriptors.c **** const USB_Descriptor_String_t PROGMEM LanguageString =
 179:Descriptors.c **** {
 180:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(1), .Type = DTYPE_String},
 181:Descriptors.c **** 
 182:Descriptors.c **** 	.UnicodeString          = {LANGUAGE_ID_ENG}
 183:Descriptors.c **** };
 184:Descriptors.c **** 
 185:Descriptors.c **** /** Manufacturer descriptor string. This is a Unicode string containing the manufacturer's details 
 186:Descriptors.c ****  *  form, and is read out upon request by the host when the appropriate string ID is requested, lis
 187:Descriptors.c ****  *  Descriptor.
 188:Descriptors.c ****  */
 189:Descriptors.c **** const USB_Descriptor_String_t PROGMEM ManufacturerString =
 190:Descriptors.c **** {
 191:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(7), .Type = DTYPE_String},
 192:Descriptors.c **** 
 193:Descriptors.c **** 	.UnicodeString          = L"Arduino"
 194:Descriptors.c **** };
 195:Descriptors.c **** 
 196:Descriptors.c **** /** Product descriptor string. This is a Unicode string containing the product's details in human r
 197:Descriptors.c ****  *  and is read out upon request by the host when the appropriate string ID is requested, listed in
 198:Descriptors.c ****  *  Descriptor.
 199:Descriptors.c ****  */
 200:Descriptors.c **** const USB_Descriptor_String_t PROGMEM ProductString =
 201:Descriptors.c **** {
 202:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(20), .Type = DTYPE_String},
 203:Descriptors.c **** 
 204:Descriptors.c **** 	.UnicodeString          = L"Arduino PPM Joystick"
 205:Descriptors.c **** };
 206:Descriptors.c **** 
 207:Descriptors.c **** /** This function is called by the library when in device mode, and must be overridden (see library
 208:Descriptors.c ****  *  documentation) by the application code so that the address and size of a requested descriptor c
 209:Descriptors.c ****  *  to the USB library. When the device receives a Get Descriptor request on the control endpoint, 
 210:Descriptors.c ****  *  is called so that the descriptor details can be passed back and the appropriate descriptor sent
 211:Descriptors.c ****  *  USB host.
 212:Descriptors.c ****  */
 213:Descriptors.c **** uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
 214:Descriptors.c ****                                     const uint8_t wIndex,
 215:Descriptors.c ****                                     void** const DescriptorAddress)
 216:Descriptors.c **** {
  16               		.loc 1 216 0
  17               		.cfi_startproc
  18               	.LVL0:
  19               	/* prologue: function */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
 217:Descriptors.c **** 	const uint8_t  DescriptorType   = (wValue >> 8);
  23               		.loc 1 217 0
  24 0000 292F      		mov r18,r25
  25 0002 3327      		clr r19
 218:Descriptors.c **** 	const uint8_t  DescriptorNumber = (wValue & 0xFF);
 219:Descriptors.c **** 
 220:Descriptors.c **** 	void*    Address = NULL;
 221:Descriptors.c **** 	uint16_t Size    = NO_DESCRIPTOR;
 222:Descriptors.c **** 
 223:Descriptors.c **** 	switch (DescriptorType)
  26               		.loc 1 223 0
  27 0004 2330      		cpi r18,3
  28 0006 3105      		cpc r19,__zero_reg__
  29 0008 01F0      		breq .L3
  30 000a 04F4      		brge .L4
  31 000c 2130      		cpi r18,1
  32 000e 3105      		cpc r19,__zero_reg__
  33 0010 01F0      		breq .L5
  34 0012 2230      		cpi r18,2
  35 0014 3105      		cpc r19,__zero_reg__
  36 0016 01F4      		brne .L14
  37               	.LVL1:
 224:Descriptors.c **** 	{
 225:Descriptors.c **** 		case DTYPE_Device:
 226:Descriptors.c **** 			Address = (void*)&DeviceDescriptor;
 227:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Device_t);
 228:Descriptors.c **** 			break;
 229:Descriptors.c **** 		case DTYPE_Configuration:
 230:Descriptors.c **** 			Address = (void*)&ConfigurationDescriptor;
 231:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Configuration_t);
  38               		.loc 1 231 0
  39 0018 82E2      		ldi r24,lo8(34)
  40 001a 90E0      		ldi r25,0
  41               	.LVL2:
 230:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Configuration_t);
  42               		.loc 1 230 0
  43 001c 20E0      		ldi r18,lo8(ConfigurationDescriptor)
  44 001e 30E0      		ldi r19,hi8(ConfigurationDescriptor)
 232:Descriptors.c **** 			break;
  45               		.loc 1 232 0
  46 0020 00C0      		rjmp .L2
  47               	.LVL3:
  48               	.L4:
 223:Descriptors.c **** 	{
  49               		.loc 1 223 0
  50 0022 2132      		cpi r18,33
  51 0024 3105      		cpc r19,__zero_reg__
  52 0026 01F0      		breq .L7
  53 0028 2232      		cpi r18,34
  54 002a 3105      		cpc r19,__zero_reg__
  55 002c 01F4      		brne .L14
  56               	.LVL4:
 233:Descriptors.c **** 		case DTYPE_String:
 234:Descriptors.c **** 			switch (DescriptorNumber)
 235:Descriptors.c **** 			{
 236:Descriptors.c **** 				case 0x00:
 237:Descriptors.c **** 					Address = (void*)&LanguageString;
 238:Descriptors.c **** 					Size    = pgm_read_byte(&LanguageString.Header.Size);
 239:Descriptors.c **** 					break;
 240:Descriptors.c **** 				case 0x01:
 241:Descriptors.c **** 					Address = (void*)&ManufacturerString;
 242:Descriptors.c **** 					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
 243:Descriptors.c **** 					break;
 244:Descriptors.c **** 				case 0x02:
 245:Descriptors.c **** 					Address = (void*)&ProductString;
 246:Descriptors.c **** 					Size    = pgm_read_byte(&ProductString.Header.Size);
 247:Descriptors.c **** 					break;
 248:Descriptors.c **** 			}
 249:Descriptors.c **** 
 250:Descriptors.c **** 			break;
 251:Descriptors.c **** 		case DTYPE_HID:
 252:Descriptors.c **** 			Address = (void*)&ConfigurationDescriptor.HID_JoystickHID;
 253:Descriptors.c **** 			Size    = sizeof(USB_HID_Descriptor_t);
 254:Descriptors.c **** 			break;
 255:Descriptors.c **** 		case DTYPE_Report:
 256:Descriptors.c **** 			Address = (void*)&JoystickReport;
 257:Descriptors.c **** 			Size    = sizeof(JoystickReport);
  57               		.loc 1 257 0
  58 002e 81E2      		ldi r24,lo8(33)
  59 0030 90E0      		ldi r25,0
  60               	.LVL5:
 256:Descriptors.c **** 			Size    = sizeof(JoystickReport);
  61               		.loc 1 256 0
  62 0032 20E0      		ldi r18,lo8(JoystickReport)
  63 0034 30E0      		ldi r19,hi8(JoystickReport)
 258:Descriptors.c **** 			break;
  64               		.loc 1 258 0
  65 0036 00C0      		rjmp .L2
  66               	.LVL6:
  67               	.L5:
 227:Descriptors.c **** 			break;
  68               		.loc 1 227 0
  69 0038 82E1      		ldi r24,lo8(18)
  70 003a 90E0      		ldi r25,0
  71               	.LVL7:
 226:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Device_t);
  72               		.loc 1 226 0
  73 003c 20E0      		ldi r18,lo8(DeviceDescriptor)
  74 003e 30E0      		ldi r19,hi8(DeviceDescriptor)
  75 0040 00C0      		rjmp .L2
  76               	.LVL8:
  77               	.L3:
  78 0042 9927      		clr r25
  79               	.LVL9:
 234:Descriptors.c **** 			{
  80               		.loc 1 234 0
  81 0044 8130      		cpi r24,1
  82 0046 9105      		cpc r25,__zero_reg__
  83 0048 01F0      		breq .L9
  84 004a 8230      		cpi r24,2
  85 004c 9105      		cpc r25,__zero_reg__
  86 004e 01F0      		breq .L10
  87 0050 892B      		or r24,r25
  88 0052 01F4      		brne .L14
  89               	.LVL10:
  90               	.LBB2:
 238:Descriptors.c **** 					break;
  91               		.loc 1 238 0
  92 0054 E0E0      		ldi r30,lo8(LanguageString)
  93 0056 F0E0      		ldi r31,hi8(LanguageString)
  94 0058 00C0      		rjmp .L15
  95               	.LVL11:
  96               	.L9:
  97               	.LBE2:
  98               	.LBB3:
 242:Descriptors.c **** 					break;
  99               		.loc 1 242 0
 100 005a E0E0      		ldi r30,lo8(ManufacturerString)
 101 005c F0E0      		ldi r31,hi8(ManufacturerString)
 102 005e 00C0      		rjmp .L15
 103               	.LVL12:
 104               	.L10:
 105               	.LBE3:
 106               	.LBB4:
 246:Descriptors.c **** 					break;
 107               		.loc 1 246 0
 108 0060 E0E0      		ldi r30,lo8(ProductString)
 109 0062 F0E0      		ldi r31,hi8(ProductString)
 110               	.LVL13:
 111               	.L15:
 112               	/* #APP */
 113               	 ;  246 "Descriptors.c" 1
 114 0064 8491      		lpm r24, Z
 115               		
 116               	 ;  0 "" 2
 117               	.LVL14:
 118               	/* #NOAPP */
 119               	.LBE4:
 120 0066 90E0      		ldi r25,0
 121               	.LVL15:
 245:Descriptors.c **** 					Size    = pgm_read_byte(&ProductString.Header.Size);
 122               		.loc 1 245 0
 123 0068 9F01      		movw r18,r30
 247:Descriptors.c **** 			}
 124               		.loc 1 247 0
 125 006a 00C0      		rjmp .L2
 126               	.LVL16:
 127               	.L7:
 253:Descriptors.c **** 			break;
 128               		.loc 1 253 0
 129 006c 89E0      		ldi r24,lo8(9)
 130 006e 90E0      		ldi r25,0
 131               	.LVL17:
 252:Descriptors.c **** 			Size    = sizeof(USB_HID_Descriptor_t);
 132               		.loc 1 252 0
 133 0070 20E0      		ldi r18,lo8(ConfigurationDescriptor+18)
 134 0072 30E0      		ldi r19,hi8(ConfigurationDescriptor+18)
 135               	.LVL18:
 254:Descriptors.c **** 		case DTYPE_Report:
 136               		.loc 1 254 0
 137 0074 00C0      		rjmp .L2
 138               	.LVL19:
 139               	.L14:
 221:Descriptors.c **** 
 140               		.loc 1 221 0
 141 0076 80E0      		ldi r24,0
 142 0078 90E0      		ldi r25,0
 220:Descriptors.c **** 	uint16_t Size    = NO_DESCRIPTOR;
 143               		.loc 1 220 0
 144 007a 20E0      		ldi r18,0
 145 007c 30E0      		ldi r19,0
 146               	.LVL20:
 147               	.L2:
 259:Descriptors.c **** 	}
 260:Descriptors.c **** 
 261:Descriptors.c **** 	*DescriptorAddress = Address;
 148               		.loc 1 261 0
 149 007e FA01      		movw r30,r20
 150 0080 3183      		std Z+1,r19
 151 0082 2083      		st Z,r18
 262:Descriptors.c **** 	return Size;
 263:Descriptors.c **** }
 152               		.loc 1 263 0
 153 0084 0895      		ret
 154               		.cfi_endproc
 155               	.LFE66:
 157               	.global	ProductString
 158               		.section	.progmem.data,"a",@progbits
 161               	ProductString:
 162 0000 2A        		.byte	42
 163 0001 03        		.byte	3
 164 0002 4100      		.string	"A"
 165 0004 7200      		.string	"r"
 166 0006 6400      		.string	"d"
 167 0008 7500      		.string	"u"
 168 000a 6900      		.string	"i"
 169 000c 6E00      		.string	"n"
 170 000e 6F00      		.string	"o"
 171 0010 2000      		.string	" "
 172 0012 5000      		.string	"P"
 173 0014 5000      		.string	"P"
 174 0016 4D00      		.string	"M"
 175 0018 2000      		.string	" "
 176 001a 4A00      		.string	"J"
 177 001c 6F00      		.string	"o"
 178 001e 7900      		.string	"y"
 179 0020 7300      		.string	"s"
 180 0022 7400      		.string	"t"
 181 0024 6900      		.string	"i"
 182 0026 6300      		.string	"c"
 183 0028 6B00      		.string	"k"
 184 002a 00        		.string	""
 185 002b 00        		.string	""
 186               	.global	ManufacturerString
 189               	ManufacturerString:
 190 002c 10        		.byte	16
 191 002d 03        		.byte	3
 192 002e 4100      		.string	"A"
 193 0030 7200      		.string	"r"
 194 0032 6400      		.string	"d"
 195 0034 7500      		.string	"u"
 196 0036 6900      		.string	"i"
 197 0038 6E00      		.string	"n"
 198 003a 6F00      		.string	"o"
 199 003c 00        		.string	""
 200 003d 00        		.string	""
 201               	.global	LanguageString
 204               	LanguageString:
 205 003e 04        		.byte	4
 206 003f 03        		.byte	3
 207 0040 0904      		.word	1033
 208               	.global	ConfigurationDescriptor
 211               	ConfigurationDescriptor:
 212 0042 09        		.byte	9
 213 0043 02        		.byte	2
 214 0044 2200      		.word	34
 215 0046 01        		.byte	1
 216 0047 01        		.byte	1
 217 0048 00        		.byte	0
 218 0049 C0        		.byte	-64
 219 004a 32        		.byte	50
 220 004b 09        		.byte	9
 221 004c 04        		.byte	4
 222 004d 00        		.byte	0
 223 004e 00        		.byte	0
 224 004f 01        		.byte	1
 225 0050 03        		.byte	3
 226 0051 00        		.byte	0
 227 0052 00        		.byte	0
 228 0053 00        		.byte	0
 229 0054 09        		.byte	9
 230 0055 21        		.byte	33
 231 0056 1101      		.word	273
 232 0058 00        		.byte	0
 233 0059 01        		.byte	1
 234 005a 22        		.byte	34
 235 005b 2100      		.word	33
 236 005d 07        		.byte	7
 237 005e 05        		.byte	5
 238 005f 81        		.byte	-127
 239 0060 03        		.byte	3
 240 0061 0800      		.word	8
 241 0063 0A        		.byte	10
 242               	.global	DeviceDescriptor
 245               	DeviceDescriptor:
 246 0064 12        		.byte	18
 247 0065 01        		.byte	1
 248 0066 1001      		.word	272
 249 0068 00        		.byte	0
 250 0069 00        		.byte	0
 251 006a 00        		.byte	0
 252 006b 08        		.byte	8
 253 006c EB03      		.word	1003
 254 006e 4320      		.word	8259
 255 0070 0000      		.word	0
 256 0072 01        		.byte	1
 257 0073 02        		.byte	2
 258 0074 00        		.byte	0
 259 0075 01        		.byte	1
 260               	.global	JoystickReport
 263               	JoystickReport:
 264 0076 05        		.byte	5
 265 0077 01        		.byte	1
 266 0078 09        		.byte	9
 267 0079 04        		.byte	4
 268 007a A1        		.byte	-95
 269 007b 01        		.byte	1
 270 007c 09        		.byte	9
 271 007d 01        		.byte	1
 272 007e A1        		.byte	-95
 273 007f 00        		.byte	0
 274 0080 05        		.byte	5
 275 0081 01        		.byte	1
 276 0082 09        		.byte	9
 277 0083 30        		.byte	48
 278 0084 09        		.byte	9
 279 0085 31        		.byte	49
 280 0086 09        		.byte	9
 281 0087 32        		.byte	50
 282 0088 09        		.byte	9
 283 0089 33        		.byte	51
 284 008a 15        		.byte	21
 285 008b 00        		.byte	0
 286 008c 26        		.byte	38
 287 008d D0        		.byte	-48
 288 008e 07        		.byte	7
 289 008f 75        		.byte	117
 290 0090 10        		.byte	16
 291 0091 95        		.byte	-107
 292 0092 04        		.byte	4
 293 0093 81        		.byte	-127
 294 0094 82        		.byte	-126
 295 0095 C0        		.byte	-64
 296 0096 C0        		.byte	-64
 297               		.text
 298               	.Letext0:
 299               		.file 2 "/opt/local/avr/include/stdint.h"
 300               		.file 3 "/opt/local/lib/gcc/avr/4.9.1/include/stddef.h"
 301               		.file 4 "../../LUFA/Drivers/USB/HighLevel/../LowLevel/../HighLevel/StdDescriptors.h"
 302               		.file 5 "../../LUFA/Drivers/USB/Class/Device/../Common/HID.h"
 303               		.file 6 "Descriptors.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Descriptors.c
/var/folders/6c/g9rchb4n5wx9ngrpwqx6t52c0000gn/T//ccTh7FdH.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/6c/g9rchb4n5wx9ngrpwqx6t52c0000gn/T//ccTh7FdH.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/6c/g9rchb4n5wx9ngrpwqx6t52c0000gn/T//ccTh7FdH.s:4      *ABS*:000000000000003f __SREG__
/var/folders/6c/g9rchb4n5wx9ngrpwqx6t52c0000gn/T//ccTh7FdH.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/6c/g9rchb4n5wx9ngrpwqx6t52c0000gn/T//ccTh7FdH.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/6c/g9rchb4n5wx9ngrpwqx6t52c0000gn/T//ccTh7FdH.s:13     .text.CALLBACK_USB_GetDescriptor:0000000000000000 CALLBACK_USB_GetDescriptor
/var/folders/6c/g9rchb4n5wx9ngrpwqx6t52c0000gn/T//ccTh7FdH.s:211    .progmem.data:0000000000000042 ConfigurationDescriptor
/var/folders/6c/g9rchb4n5wx9ngrpwqx6t52c0000gn/T//ccTh7FdH.s:263    .progmem.data:0000000000000076 JoystickReport
/var/folders/6c/g9rchb4n5wx9ngrpwqx6t52c0000gn/T//ccTh7FdH.s:245    .progmem.data:0000000000000064 DeviceDescriptor
/var/folders/6c/g9rchb4n5wx9ngrpwqx6t52c0000gn/T//ccTh7FdH.s:204    .progmem.data:000000000000003e LanguageString
/var/folders/6c/g9rchb4n5wx9ngrpwqx6t52c0000gn/T//ccTh7FdH.s:189    .progmem.data:000000000000002c ManufacturerString
/var/folders/6c/g9rchb4n5wx9ngrpwqx6t52c0000gn/T//ccTh7FdH.s:161    .progmem.data:0000000000000000 ProductString

NO UNDEFINED SYMBOLS
